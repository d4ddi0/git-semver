#!/usr/bin/env python
"""
git_semver is an alternative to git describe, which instead of
describing a revision in terms of distance from the last release, parses
the commit headers to determine what the NEXT release will be, following
the rules of Semantic Versioning (see https://semver.org/)
"""

import argparse
import logging
import re
import subprocess

COMMIT_TYPE_IGNORE = 0
COMMIT_TYPE_PATCH = 1
COMMIT_TYPE_MINOR = 2
COMMIT_TYPE_MAJOR = 3

COMMIT_NAMES_IGNORE = ('ignore', 'docs', 'style', 'test', 'chore')
COMMIT_NAMES_PATCH = ('patch', 'fix', 'dep', 'refactor')
COMMIT_NAMES_MINOR = ('minor', 'feature')
COMMIT_NAMES_MAJOR = ('major', 'apichange')

def git_semver_check_message(msg):
    match = re.match('([a-z]+)(\([a-z]+\))?: ', msg)
    if match is None:
        raise Exception('invalid commit header format: "' + msg + '"')
    commit_type = match.group(1)
    if commit_type in COMMIT_NAMES_MAJOR:
        return COMMIT_TYPE_MAJOR
    elif commit_type in COMMIT_NAMES_MINOR:
        return COMMIT_TYPE_MINOR
    elif commit_type in COMMIT_NAMES_PATCH:
        return COMMIT_TYPE_PATCH
    elif commit_type in COMMIT_NAMES_IGNORE:
        return COMMIT_TYPE_IGNORE
    else:
        raise Exception('invalid commit type: ' + commit_type)

def git_semver_get_last_version(commit, prefix=None, suffix=''):
    if prefix is None:
        prefix = '\D*'
    try:
        git_desc = subprocess.check_output(['git', 'describe', commit])
        template = r'({}(\d+)\.(\d+)\.(\d+){})(-\d+-g[a-f0-9]+)?$'
        ver_regex = template.format(prefix, suffix)
        match = re.match(ver_regex, git_desc)
        last_tag, major, minor, patch, short_commit = match.groups()
    except subprocess.CalledProcessError:
        #git describe returned nothing. We are pre initial release
        cmd = ['git', 'rev-list', '--max-parents=0', commit]
        last_tag = subprocess.check_output(cmd).strip()
        major = 0
        minor = 0
        patch = 0
        cmd2 = ['git', 'rev-parse', '--short', commit]
        short_commit = subprocess.check_output(cmd2).strip()
        cmd3 = ['git', 'rev-list', '--count', last_tag + '..' + commit]
        post_commit_revs = subprocess.check_output(cmd3).strip()
        short_commit = '-{}-g{}'.format(post_commit_revs, short_commit)

    return last_tag, major, minor, patch, short_commit

def git_semver(commit=None, release=False, prefix=None):
    if commit is None:
        commit = 'HEAD'

    last_tag, major, minor, patch, short_commit = \
            git_semver_get_last_version(commit, prefix)
    log_cmd = ['git', 'log', '--format=%s', last_tag + '..' + commit]

    version_bump = 0
    msgs = subprocess.check_output(log_cmd).splitlines()
    if not msgs:
        release = True
    else:
        for msg in subprocess.check_output(log_cmd).splitlines():
            try:
                version_bump = max(version_bump, git_semver_check_message(msg))
            except Exception as e:
                logging.warn(e.message + ': skipped invalid commit')

    if version_bump == COMMIT_TYPE_PATCH:
        patch = int(patch) + 1
    elif version_bump == COMMIT_TYPE_MINOR:
        patch = 0
        minor = int(minor) + 1
    elif version_bump == COMMIT_TYPE_MAJOR:
        patch = 0
        minor = 0
        major = int(major) + 1
    else: # COMMIT_TYPE_IGNORE
        pass

    if release:
        suffix = ''
    elif version_bump:
        suffix = '~pre' + short_commit.replace('-','+')
    else:
        suffix = short_commit.replace('-','+')

    return '{}.{}.{}{}'.format(major, minor, patch, suffix)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-r', '--release', action='store_true', help='output the next release version without any prerelease suffix')
    parser.add_argument('-c', '--commit', type=str, help='select a specific commit. defaults to the current HEAD')

    print(git_semver(**vars(parser.parse_args())))

